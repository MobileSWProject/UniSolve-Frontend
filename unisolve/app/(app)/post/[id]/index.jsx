import { Ionicons } from "@expo/vector-icons";
import {
  useFocusEffect,
  useLocalSearchParams,
  usePathname,
  useRouter,
} from "expo-router";
import {
  Image,
  Text,
  TouchableOpacity,
  View,
  TextInput,
  Modal,
} from "react-native";
import styles from "../../../../styles/post/PostStyles";
import { useCallback, useState, useEffect } from "react";
import _axios from "../../../../api";
import {
  ReplyCommentIdProvider,
  useReplyCommentId,
} from "../../../../components/post/ReplyCommentIdContext";
import { KeyboardAwareScrollView } from "react-native-keyboard-aware-scroll-view";
import useUserId from "../../../../hooks/useUserId"; // Ïª§Ïä§ÌÖÄ ÌõÖ Î∂àÎü¨Ïò§Í∏∞
import formatAuthor from "../../../../utils/formatAuthor";
import { mainColor } from "../../../../constants/Colors";
import { Snackbar, Provider as PaperProvider } from "react-native-paper";
import CommentSection from "../../../../components/post/CommentSection";

import { useTranslation } from 'react-i18next';
import "../../../../i18n";

const Post = () => {
  const { t } = useTranslation();
  const { id } = useLocalSearchParams();
  const [data, setData] = useState(null);

  const [ban, setBan] = useState(false);

  const [newComment, setNewComment] = useState(""); // ÏÉà ÎåìÍ∏Ä ÎÇ¥Ïö© Ï†ÄÏû•
  const [replyComment, setReplyComment] = useState(""); // ÎåÄÎåìÍ∏Ä ÎÇ¥Ïö© Ï†ÄÏû•
  const [modalVisible, setModalVisible] = useState(false);
  const [reportReason, setReportReason] = useState("");
  const [commentID, setCommentID] = useState(null);
  const [snackbarVisible, setSnackbarVisible] = useState(false);
  const [snackbarMessage, setSnackbarMessage] = useState("");
  const [process, setProcess] = useState(false);

  const [editTitle, setEditTitle] = useState("");
  const [editContent, setEditContent] = useState("");
  const [editComment, setEditComment] = useState("");
  const [editing, setEditing] = useState(false);

  const [editPost, setEditPost] = useState(false);

  const { userId } = useUserId(); // Ïª§Ïä§ÌÖÄ ÌõÖÏúºÎ°ú userId Î∂àÎü¨Ïò§Í∏∞
  const { selectedComment, setSelectedComment } = useReplyCommentId();

  const pathname = usePathname();
  const router = useRouter();

  // selectedCommentÍ∞Ä Î≥ÄÍ≤ΩÎê† ÎïåÎßàÎã§ replyComment Ï¥àÍ∏∞Ìôî
  useEffect(() => {
    if (selectedComment) {
      setReplyComment(""); // selectedCommentÍ∞Ä Î≥ÄÍ≤ΩÎê† ÎïåÎßå Ïã§Ìñâ
    }
  }, [selectedComment]);

  useFocusEffect(
    useCallback(() => {
      const getData = async () => {
        _axios
          .get(`/posts/${id}`)
          .then((response) => {
            setBan(response.data.ban);
            setData({
              id: response.data.id,
              private: Boolean(response.data.is_private),
              authorId: formatAuthor(response.data.author_id),
              nickname: formatAuthor(
                response.data.author_nickname ||
                  `${response.data.author_id}_temp_nickname`
              ),
              title: response.data.title,
              content: response.data.description,
              timestamp: response.data.timestamp,
              image: response.data.image,
              comments: response.data.comments,
              commentsCount: response.data.comments_count,
            });
          })
          .catch((error) => {
            router.replace("community");
          });
      };

      getData();
    }, [id])
  );

  // ÎåìÍ∏Ä ÎòêÎäî ÎåÄÎåìÍ∏Ä Ï∂îÍ∞Ä Î°úÏßÅ
  const handleAddComment = async (isReply) => {
    const commentContent = isReply ? replyComment : newComment;
    if (!commentContent) {
      console.log("ÎåìÍ∏Ä ÎÇ¥Ïö©Ïù¥ ÏûàÏñ¥ÏïºÌï©ÎãàÎã§.");
      return;
    }

    try {
      let data = JSON.stringify({
        post_id: id,
        content: commentContent,
        parent_id: isReply ? selectedComment : null,
      });
      const response = await _axios.post("/comments", data);

      // ÎåìÍ∏Ä Ï∂îÍ∞Ä ÌõÑ ÎåìÍ∏Ä Î™©Î°ùÎßå Îã§Ïãú Î∂àÎü¨Ïò¥
      const updatedPost = await _axios.get(`/posts/${id}`);
      setData((prev) => ({
        ...prev,
        comments: updatedPost.data.comments,
        commentsCount: updatedPost.data.comments_count,
      }));
    } catch (error) {
      console.log(error);
    } finally {
      setNewComment("");
      setReplyComment("");
      setSelectedComment(null);
    }
  };

  const handleRemoveComment = async (targetCommentId) => {
    try {
      const response = await _axios.delete(`/comments/${targetCommentId}`);

      // ÎåìÍ∏Ä ÏÇ≠Ï†ú ÌõÑ ÎåìÍ∏Ä Î™©Î°ùÎßå Îã§Ïãú Î∂àÎü¨Ïò¥
      const updatedPost = await _axios.get(`/posts/${id}`);
      setData((prev) => ({
        ...prev,
        comments: updatedPost.data.comments,
        commentsCount: updatedPost.data.comments_count,
      }));
    } catch (error) {
      // "something error üò≠"
      console.log("Something Error üò≠");
    }
  };

  const handleUpdateComment = async (targetCommentId) => {
    try {
      const response = await _axios.put(`/comments/${targetCommentId}`, {
        content: editComment,
      });
      if (response.data.status === "success") {
        setEditComment("");
        setEditing(false);
        // ÎåìÍ∏Ä ÏàòÏ†ï ÌõÑ ÎåìÍ∏Ä Î™©Î°ùÎßå Îã§Ïãú Î∂àÎü¨Ïò¥
        const updatedPost = await _axios.get(`/posts/${id}`);
        setData((prev) => ({
          ...prev,
          comments: updatedPost.data.comments,
          commentsCount: updatedPost.data.comments_count,
        }));
      }
      setSnackbarVisible(true);
      setSnackbarMessage(t("Function.edit"));
    } catch (error) {
      // "something error üò≠"
      console.log("Something Error üò≠");
    }
  };

  const handleReport = async () => {
    if (reportReason.length < 1 || process) return;
    try {
      setProcess(true);
      const response = await _axios.post(`/reports`, {
        post_id: id,
        comment_id: commentID || null,
        reason: reportReason,
      });
      setProcess(false);
      setModalVisible(false);
      setCommentID(null);
      if (response.data.status === "success") {
        setReportReason("");
        setSnackbarMessage(t("Function.report_success"));
        setSnackbarVisible(true);
      }
    } catch (error) {
      setProcess(false);
      setModalVisible(false);
      setSnackbarMessage(t("Function.report_failed"));
      setSnackbarVisible(true);
    }
  };

  // comment_idÎ•º ÏÑ†ÌÉùÌïú ÌõÑ ÎåÄÎåìÍ∏Ä Ï¥àÍ∏∞ÌôîÎäî useEffectÏóêÏÑú Ï≤òÎ¶¨
  const handleReply = (comment) => {
    setSelectedComment(comment.comment_id);
  };

  const handleRemovePost = async () => {
    try {
      const response = await _axios.delete(`/posts/${id}`);

      if (router.canGoBack()) {
        router.back();
      } else {
        router.replace("/community");
      }
    } catch (error) {
      // "something error üò≠"
      console.log("Something Error üò≠");
    }
  };

  const handleUpdatePost = async () => {
    try {
      if (editTitle.length < 1 || editContent.length < 1 || process) return;
      setModalVisible(false);
      setEditTitle("");
      setEditContent("");
      setEditing(false);
      setProcess(true);
      const response = await _axios.put(`/posts/${id}`, {
        title: editTitle,
        content: editContent,
      });
      if (response.data.status === "success") {
        // Í≤åÏãúÍ∏Ä ÏàòÏ†ï ÌõÑ Îã§Ïãú Î∂àÎü¨Ïò§Í∏∞
        const updatedPost = await _axios.get(`/posts/${id}`);
        setData((prev) => ({
          ...prev,
          title: updatedPost.data.title,
          content: updatedPost.data.description,
          timestamp: updatedPost.data.timestamp,
          comments: updatedPost.data.comments,
          commentsCount: updatedPost.data.comments_count,
        }));
      }
      setSnackbarMessage(t("Function.edit"));
      setSnackbarVisible(true);
      setProcess(false);
    } catch (error) {
      setProcess(false);
      console.log("Something Error üò≠");
    }
  };

  if (!data) {
    return <></>;
  }

  return (
    <KeyboardAwareScrollView style={styles.container}>
      <View style={styles.contentContainer}>
        {data.image && (
          <Image
            source={{ uri: data.image }}
            style={styles.image}
          />
        )}
        <View
          style={{
            flexDirection: "row",
            justifyContent: "space-between",
            alignItems: "center",
            marginBottom: 10,
            minHeight: 30,
          }}
        >
          <Text style={styles.title}>{data.title}</Text>
          {formatAuthor(data.authorId) === formatAuthor(userId) ? (
            <View style={{ flexDirection: "row" }}>
              <TouchableOpacity
                hitSlop={8}
                onPress={() => {
                  setEditPost(true);
                  setEditTitle(data.title);
                  setEditContent(data.content);
                  setModalVisible(true);
                }}
              >
                <Text style={{ fontSize: 12 }}>‚úèÔ∏è</Text>
              </TouchableOpacity>
              <TouchableOpacity
                hitSlop={8}
                onPress={() => handleRemovePost()}
              >
                <Text style={{ fontSize: 12 }}>‚ùå</Text>
              </TouchableOpacity>
            </View>
          ) : (
            <TouchableOpacity
              hitSlop={8}
              onPress={() => {
                setEditPost(false);
                setModalVisible(true);
              }}
            >
              <Text style={{ fontSize: 12 }}>üö®</Text>
            </TouchableOpacity>
          )}
        </View>
        <View style={styles.privateStatusContainer}>
          <Ionicons
            name={data.private ? "lock-closed" : "earth-sharp"}
            size={16}
            color="#666"
            style={styles.privateStatusIcon}
          />
          <Text style={styles.privateStatusText}>
            {data.private ? t("Function.private") : t("Function.public")}
          </Text>
        </View>
        <Text style={styles.userInfo}>
          {formatAuthor(data.nickname)} ‚Ä¢ {data.timestamp}
        </Text>
        <Text style={styles.content}>{data.content}</Text>
      </View>

      {/* ÎπÑÍ≥µÍ∞ú Ï±ÑÌåÖ Î≤ÑÌäº */}
      <View style={styles.chatButtonContainer}>
        <TouchableOpacity
          onPress={() => router.push(`${pathname}/chat`)}
          style={styles.chatButtonTouchArea}
          hitSlop={4}
        >
          <Text style={styles.chatButtonText}>{t("Function.chat")}</Text>
        </TouchableOpacity>
      </View>

      {/* Í≤åÏãúÍ∏Ä ÎåìÍ∏Ä ÏûÖÎ†• ÌïÑÎìú */}
      <View style={styles.commentInputContainer}>
        <TextInput
          style={[styles.commentInput, {backgroundColor: ban ? "#ccc" : "#fff"}]}
          placeholder={ban ? t("Function.forbidden") : t("Function.input_content")}
          placeholderTextColor={"black"}
          value={newComment}
          onChangeText={(text) => setNewComment(text)}
          multiline={true}
          disabled={ban}
        />
        <TouchableOpacity
          style={[styles.commentButton, {backgroundColor: ban ? "#ccc" : mainColor}]}
          onPress={() => handleAddComment(false)}
          disabled={ban}
        >
          <Text style={styles.commentButtonText}>{t("Function.regist")}</Text>
        </TouchableOpacity>
      </View>

      {/* ÎåìÍ∏Ä Î†åÎçîÎßÅ */}
      <View style={styles.commentContainer}>
        <Text style={styles.commentTitle}>{t("Function.comment")} {data.commentsCount}{t("Function.count")}</Text>
        {data.comments.map((comment, index) => (
          <CommentSection
            ban={ban}
            key={comment.comment_id}
            comment={comment}
            userId={userId}
            handleUpdateComment={handleUpdateComment}
            handleRemoveComment={handleRemoveComment}
            handleReportComment={(commentId) => {
              setEditPost(false);
              setModalVisible(true);
              setCommentID(commentId);
            }}
            handleReply={handleReply}
            handleAddComment={handleAddComment}
            selectedComment={selectedComment}
            setSelectedComment={setSelectedComment}
            replyComment={replyComment}
            setReplyComment={setReplyComment}
            isReply={false} // Top-level comment, not a reply
            setEditComment={setEditComment}
            setEditing={setEditing}
            editing={editing}
            editComment={editComment}
          />
        ))}

        <Modal
          animationType="fade"
          transparent={true}
          visible={modalVisible}
          onRequestClose={() => {
            setCommentID(null);
            setModalVisible(false);
            setEditTitle("");
            setEditContent("");
          }}
        >
          <View style={styles.centeredView}>
            <View style={styles.modalView}>
              {editPost ? (
                <>
                  <TextInput
                    style={styles.commentInput}
                    placeholder={t("Function.title")}
                    value={editTitle}
                    onChangeText={(text) => setEditTitle(text)}
                    multiline={true}
                  />
                  <TextInput
                    style={styles.commentInput}
                    placeholder={t("Function.content")}
                    value={editContent}
                    onChangeText={(text) => setEditContent(text)}
                    multiline={true}
                  />
                </>
              ) : (
                <TextInput
                  style={styles.commentInput}
                  placeholder={t("Function.input_content")}
                  value={reportReason}
                  onChangeText={(text) => setReportReason(text)}
                  multiline={true}
                />
              )}
              <TouchableOpacity
                disabled={false}
                style={[
                  styles.buttonSmall,
                  { backgroundColor: false ? "gray" : mainColor },
                ]}
                onPress={() => {
                  setCommentID(null);
                  setModalVisible(false);
                  setEditTitle("");
                  setEditContent("");
                }}
              >
                <Text style={styles.buttonTextSmall}>{t("Function.cancel")}</Text>
              </TouchableOpacity>
              <TouchableOpacity
                disabled={false}
                style={[
                  styles.buttonSmall,
                  { backgroundColor: false ? "gray" : mainColor },
                ]}
                onPress={() => {
                  editPost ? handleUpdatePost() : handleReport();
                }}
              >
                <Text style={styles.buttonTextSmall}>
                  {editPost ? t("Function.btn_edit") : t("Function.btn_report")}
                </Text>
              </TouchableOpacity>
            </View>
          </View>
        </Modal>
      </View>
      {snackbarVisible ? (
        <View style={styles.snackbarContainer}>
          <Snackbar
            style={styles.snackbar}
            visible={snackbarVisible}
            onDismiss={() => {
              setSnackbarVisible(false);
              setSnackbarMessage("");
            }}
            duration={2000}
          >
            {snackbarMessage}
          </Snackbar>
        </View>
      ) : (
        <></>
      )}
    </KeyboardAwareScrollView>
  );
};

export default function PostWithReplyCommentIdProvider() {
  return (
    <ReplyCommentIdProvider>
      <Post />
    </ReplyCommentIdProvider>
  );
}
